<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>二进制原理</title>
    <meta name="description" content="展示二进制（数据和代码）的原理，演示整数（补码）、浮点数的原理、指令集设计原理。">
    <link rel="stylesheet" type="text/css" href="../style/work1Style.css">
</head>
<body>
<div class="nav">
    <div class="element">
        <a href="../index.html"><b>首页</b></a>
        <a href="work1.html"><b>二进制原理</b></a>
        <a href="work2.html"><b>计算机模型</b></a>
        <a href="work3.html"><b>代码执行流程</b></a>
        <a href="work4.html"><b>编译运行过程</b></a>
    </div>
</div>
<div class="field">
    <div class="main">
        <h1>二进制原理</h1>
        <div class="text">
            <i><b>二进制，逢二进一。</b></i>
            <h2 id="part1">为什么是二进制？</h2>
            <p>早期的计算机受到硬件，电路等因素的影响，信息传递过程中只用开和关两种状态传输的精准度要高于通过不同程度来表示多种状态的精准度，
            而且不同的程度控制需要有共同的标准才能在不同系统之间准确表达信息，这无疑增加了传递信息的难度。</p>
            <p>用二进制表示数据抗干扰能力强，可靠性高。因为数据只有高低两种状态，即使受到一定程度的损坏也比较容易辨别它是高还是低。</p>
            <p>除此之外，二进制在物理上更容易存储，如磁极取向、表面凹凸、光照有无等。</p>
            <h2 id="part2">如何表示？</h2>
            <h3>何来补码？</h3>
            <p>首先我们最朴素的思想就是直接用二进制表示十进制，如5可以表示为0000 0101，可是，-5怎么办？</p>
            <p>这简单，把数据前面的最高位当作符号位，0表示整数，1表示负数，这就是<b>原码</b>，这时5就表示为0000 0101，-5为1000 0101。</p>
            <p>既然可以表示数据，那很自然就会想到运算。根据冯·诺依曼提出的经典计算机体系结构框架，一台计算机由运算器、控制器、存储器、输入和输出设备组成。其中运算器只有加法运算器，没有减法运算器。正数和正数相加看起来一切正常，但是负数和负数相加，或者正数和负数相加却出现了莫名其妙的结果，这很明显是符号位的问题。</p>
            <p>这时我们想到了正数与负数相加为零的特点，可以把正数按位取反获得对应的相反数，即5表示为0000 0101，-5为1111 1010。这就是<b>反码</b>。</p>
            <p>使用反码进行运算，可以解决正数与负数相加的问题，可是负数与负数运算的结果确实错的，这时我们很容易发现反码的形式有两个0，一个+0，一个-0，于是我们引入了<b>补码</b>，即正数的补码等于它的原码；负数的补码等于反码+1。现在正数与负数之间的加法问题已经全部解决了。</p>
            <h3>补码的思想</h3>
            <p>想象一个时钟，就像下面这样，时钟超出显示上限，则只显示余下的钟点，这恰好是模数加法运算的体现。</p>
            <img src="../img/clock.png" alt="时钟">
            <p>按照同样的思路，在模12的前提下，9-3与9+9都可以得到相同的结果6，也就是可以将减法运算统统简化为加法运算。至于负数，把数据的钟表对半分，让负数对应其绝对值的补数。</p>
            <p>所以，所谓补码实际是一种数字映射，至于最高位的符号位，恰好在二进制下半模以下为0，半模以上为1，所以分别映射为正数和负数，这样一来符号位也就不是像前面简简单单的硬性规定了。</p>
            <h2 id="part3">小数？使用浮点数</h2>
            <h3>浮点数</h3>
            <p>以上我们只讨论了整形的数据存储，然而我们不得不面临小数的问题，这就要请出<b>浮点数</b>了。浮点数相对于定点数，是指小数点浮动也就是不确定的数据，浮点数是使用科学计数法来表示的：</p>
            <div class="formula"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi>F</mi><mo>=</mo><mi>S</mi><mo>&#x00D7;</mo><mi>M</mi><mo>&#x00D7;</mo><msup><mrow><mn>R</mn></mrow><mrow><mi>E</mi></mrow></msup></math></div>
            <p>S是符号位；M为尾数，必须用定点数表示；E为阶码，必须为整数；R为基数，二进制下为2。</p>
            <h3>规格化</h3>
            <p>如果我们那32 bit的浮点数举例，我们想要表示10.25，如下：</p>
            <ol>
                <li>S：显然是0。</li>
                <li>M：整数部分，10(D) = 1010(B)；小数部分，0.25(D) = 0.01(B)。</li>
                <li>R：科学计数法表示1010.01，指数为3。</li>
            </ol>
            <p>虽然得到了这些数据，但是到底从这32位中拿出几位来表示尾数，几位来表示阶码却没有标准，这就导致不同的人存储浮点数的方式不一样，需要一个标准来规范。</p>

            <h2 id="part4">指令集——命令CPU的口号</h2>
        </div>
    </div>
    <ol class="guide">
        <li><a href="#part1">为什么是二进制？</a></li>
        <li><a href="#part2">如何表示？</a></li>
        <li><a href="#part3">小数？使用浮点数</a></li>
        <div class="lastColumn"><li><a href="#part4">指令集——命令CPU的口号</a></li></div>
    </ol>

</div>

<footer class="down">
    <span class="info">董凡清 | 山东大学软件学院</span><br>
    <span class="mail">davinci.10.dfq@gmail.com</span>
</footer>
</body>
</html>